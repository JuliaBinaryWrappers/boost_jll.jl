# boost_jll.jl

This is an autogenerated package constructed using [`BinaryBuilder.jl`](https://github.com/JuliaPackaging/BinaryBuilder.jl).

## Products

The code bindings within this package are autogenerated from the following `Products` defined within the `build_tarballs.jl` file that generated this package:

```julia
products = [
    LibraryProduct(["libboost_math_tr1f"], :libboost_math_tr1f),
    LibraryProduct(["libboost_serialization"], :libboost_serialization),
    LibraryProduct(["libboost_context"], :libboost_context),
    LibraryProduct(["libboost_wserialization"], :libboost_wserialization),
    LibraryProduct(["libboost_iostreams"], :libboost_iostreams),
    LibraryProduct(["libboost_graph"], :libboost_graph),
    LibraryProduct(["libboost_chrono"], :libboost_chrono),
    LibraryProduct(["libboost_math_c99"], :libboost_math_c99),
    LibraryProduct(["libboost_regex"], :libboost_regex),
    LibraryProduct(["libboost_system"], :libboost_system),
    LibraryProduct(["libboost_coroutine"], :libboost_coroutine),
    LibraryProduct(["libboost_stacktrace_noop"], :libboost_stacktrace_noop),
    LibraryProduct(["libboost_container"], :libboost_container),
    LibraryProduct(["libboost_math_c99f"], :libboost_math_c99f),
    LibraryProduct(["libboost_math_tr1"], :libboost_math_tr1),
    LibraryProduct(["libboost_stacktrace_basic"], :libboost_stacktrace_basic),
    LibraryProduct(["libboost_timer"], :libboost_timer),
    LibraryProduct(["libboost_log"], :libboost_log),
    LibraryProduct(["libboost_prg_exec_monitor"], :libboost_prg_exec_monitor),
    LibraryProduct(["libboost_type_erasure"], :libboost_type_erasure),
    LibraryProduct(["libboost_math_tr1l"], :libboost_math_tr1l),
    LibraryProduct(["libboost_unit_test_framework"], :libboost_unit_test_framework),
    LibraryProduct(["libboost_contract"], :libboost_contract),
    LibraryProduct(["libboost_log_setup"], :libboost_log_setup),
    LibraryProduct(["libboost_atomic"], :libboost_atomic),
    LibraryProduct(["libboost_math_c99l"], :libboost_math_c99l),
    LibraryProduct(["libboost_program_options"], :libboost_program_options),
    LibraryProduct(["libboost_random"], :libboost_random),
    LibraryProduct(["libboost_date_time"], :libboost_date_time),
    LibraryProduct(["libboost_wave"], :libboost_wave),
    LibraryProduct(["libboost_thread"], :libboost_thread),
    LibraryProduct(["libboost_filesystem"], :libboost_filesystem)
]
```

## Usage example

For example purposes, we will assume that the following products were defined in the imaginary package `Example_jll`:

```julia
products = [
    FileProduct("src/data.txt", :data_txt),
    LibraryProduct("libdataproc", :libdataproc),
    ExecutableProduct("mungify", :mungify_exe)
]
```

With such products defined, `Example_jll` would contain `data_txt`, `libdataproc` and `mungify_exe` symbols exported. For `FileProduct` variables, the exported value is a string pointing to the location of the file on-disk.  For `LibraryProduct` variables, it is a string corresponding to the `SONAME` of the desired library (it will have already been `dlopen()`'ed, so typical `ccall()` usage applies), and for `ExecutableProduct` variables, the exported value is a function that can be called to set appropriate environment variables.  Example:

```julia
using Example_jll

# For file products, you can access its file location directly:
data_lines = open(data_txt, "r") do io
    readlines(io)
end

# For library products, you can use the exported variable name in `ccall()` invocations directly
num_chars = ccall((:count_characters, libdataproc), Cint, (Cstring, Cint), data_lines[1], length(data_lines[1]))

# For executable products, you can use the exported variable name as a function that you can call
mungify_exe() do mungify_exe_path
    run(`$mungify_exe_path $num_chars`)
end
```
